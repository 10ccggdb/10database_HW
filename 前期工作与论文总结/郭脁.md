## 前期工作

##### **使用示意图展示普通文件IO方式(fwrite等)的流程，即进程与系统内核，磁盘之间的数据交换如何进行？为什么写入完成后要调用fsync？** 

![1555978132619](C:\Users\郭脁\AppData\Local\Temp\1555978132619.png)

大多数 unix 系统为了减少磁盘 IO，采用了“延迟写”技术，也就是说当我们执行完 write 调用后，数据并不一定立马被写入磁盘（可能还是保留在系统的 buffer cache 或者 page cache 中），这样当主机突然断电，这些我们本以为已经写入到磁盘文件的数据可能就 会丢失；所以当我们需要确保数据被完整正确的写入磁盘（譬如数据库的持久化），则 需要调用同步函数 fsync，它会一直阻塞直到数据全部被写入到硬盘。



## 论文阅读

##### 为了保证指纹技术的数学证明成立，哈希函数应如何选取？ 

（哈希函数生成的哈希值具有什么特征，能简单对键值取模生成吗？） 

指纹是叶键的一个字节散列，在叶的开头连续存储。通过在搜索过程中首先 对它们进行扫描，指纹可以起到过滤作用，以避免探测指纹与搜索密钥不匹配的 密钥。只考虑唯一键的情况，证明，使用指纹技术，成功搜索过程中预期的叶内 键探针数量等于 1。在下面计算这个期望值。假设一个哈希函数生成均匀分布的 指纹。设 m 为叶中的条目数， n 为可能的哈希值（对于一个字节的指纹，n=256）。 计算叶中指纹的预期出现次数，表示为 E[k]，相当于指纹数组中哈希冲突的次 数加上一个（因为我们假设搜索键存在）： 

![1555978315995](C:\Users\郭脁\AppData\Local\Temp\1555978315995.png)

其中 p[k=i]是指搜索指纹至少出现一次的概率。 用二项分布计算，至少存在一个匹配指纹的概率，表示为不存在匹配指纹的互补 概率。 知道指纹点击的预期数量后，就可以确定叶内密钥探针的预期数量，表示为 EFPTree[T], 这是指纹点击指示的键上长度 e[k]的线性搜索中的预期键探针数 量。 

![1555978327336](C:\Users\郭脁\AppData\Local\Temp\1555978327336.png)

通过对和应用二项式定理，我们得到：计算得期望值为1。 

![1555978372935](C:\Users\郭脁\AppData\Local\Temp\1555978372935.png)

**持久化指针的作用是什么？与课上学到的什么类似？**

当程序重新启动时，它会使用一个新的地址空间来执行此操作，该地址空间会使所有存储的虚拟指针无效。 持久分配器提供持久指针和可变指针之间的双向转换。由于持久指针在失败时保持有效，因此它们用于在重新启动时刷新易失性指针。类似于LSN。